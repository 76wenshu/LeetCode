 <!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>

	//https://leetcode-cn.com/
	//官方力扣网址


// 1.字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"abcdef"。

		/*
		*
		* @param {string} s
		* @param {number} n
		* @return {string}
		*/

		// const s = 'abcdef'
		// const n = 2
		// var reverseLeftWords = function(s, n) {
		//    const strOne = s.substr(n);
		//    const strTwo = s.substr(0, n);
		//    console.log(strOne + strTwo)
		//    return strOne + strTwo	
		// };
		// reverseLeftWords(s, n);

		//截取字符串的方法
		//方法1：substring() 方法string.substring(from, to) 方法从 from 位置截取到 to 位置，to 可选，没有设置时默认到末尾。
		//方法2：substr() 方法string.substr(from, num) 方法从 from 位置截取,可在字符串中截取从开始下标开始的指定num(数目)的字符,如果没有第二个字符串那么就是从要截取的直接到最后一个字符串。
		//方法3：slice() 方法方法可提取字符串的某个部分，并以新的字符串返回被提取的部分。
		//第一种方法与第三种方法类似但是不同点是slice（）不会改变原数组

//2.给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。		
		// 示例 1：
		// 输入：num = 14
		// 输出：6
		// 解释：
		// 步骤 1) 14 是偶数，除以 2 得到 7 。
		// 步骤 2） 7 是奇数，减 1 得到 6 。
		// 步骤 3） 6 是偶数，除以 2 得到 3 。
		// 步骤 4） 3 是奇数，减 1 得到 2 。
		// 步骤 5） 2 是偶数，除以 2 得到 1 。
		// 步骤 6） 1 是奇数，减 1 得到 0 。

		/**
		 * @param {number} num
		 * @return {number}
		 */
		// var numberOfSteps  = function(num) {
		//   let i = 0;
		//   while (num > 0) {
		//     if (num % 2 === 0) {
		//       num /= 2;
		//     } else {
		//       num--;
		//     }
		//     i++;
		//   }
		//   return i;
		// };
		// console.log(numberOfSteps(14));

// 3.给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。

		// 示例 1：
		// 输入：nums = [12,345,2,6,7896]
		// 输出：2
		// 解释：
		// 12 是 2 位数字（位数为偶数） 
		// 345 是 3 位数字（位数为奇数）  
		// 2 是 1 位数字（位数为奇数） 
		// 6 是 1 位数字 位数为奇数） 
		// 7896 是 4 位数字（位数为偶数）  
		// 因此只有 12 和 7896 是位数为偶数的数字

		/**
		 * @param {number[]} nums
		 * @return {number}
		 */

		// var findNumbers = function(nums) {
		//     let i = 0
		//     nums.map(num => {
		//         if(num.toString().length%2 == 0){
		//             i++;
		//         }
		//     })
		//     return i
		// };

		//JS中.map()函数的使用

		// 一、概念

		// map()方法定义在JavaScript的Array中，它返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。
		// 注意：
		// map()不会对空数组进行检测
		// map()不会改变原始数组

		// 二、语法

		// array.map(function(currentValue, index, arr), thisIndex)
		// 参数说明：
		// function(currentValue, index, arr)：必须。为一个函数，数组中的每个元素都会执行这个函数。其中函数参数：
		// currentValue：必须。当前元素的的值。
		// index：可选。当前元素的索引。
		// arr：可选。当前元素属于的数组对象。
		// thisValue：可选。对象作为该执行回调时使用，传递给函数，用作"this"的值。

		// 三、实例

		// 返回由原数组中每个元素的平方组成的新数组：
		// let array = [1, 2, 3, 4, 5];
		// let newArray = array.map((item) => {
		//     return item * item;
		// })
		// console.log(newArray)  // [1, 4, 9, 16, 25]

		//toString() 方法可把一个 Number 对象转换为一个字符串，并返回结果。
		//语法
		//NumberObject.toString(radix)
		//param:  radix
		//radix	可选。规定表示数字的基数，使 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。但是要注意，如果该参数是 10 以外的其他值，则 ECMAScript 标准允许实现返回任意值。

		// var a = 123;
		// console.log(a.toString(2)); //1111011


// 4.实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。

		// 示例 1：
		// 输入: "Hello"
		// 输出: "hello"
		// 来源：力扣（LeetCode）
		// 链接：https://leetcode-cn.com/problems/to-lower-case
		// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

		// const str = 'HELLO';
		// const toLowerCase = function(str) {
  		//   	return str.toLowerCase();
		// };
		// console.log(toLowerCase(str));
		
		//var message="Hello world!";
		//var x=message.toUpperCase();
		//toUpperCase()这个方法是把英文字母都变为大写字母
		//一个新的字符串，在其中 stringObject 的所有小写字符全部被转换为了大写字符。

		//var message="HELLO WORLD!";
		//var x=message.toLowerCase();
		//toLowerCase()这个方法是把英文字母都变成小写字母
		// let abn = 00001111;
		// console.log(abn)
		
		// var hammingWeight = function(n) {
		//     let str = n.toString(2).replace(/0/g,'').length;
		//     console.log(str)
		//     // let str = n.toString(2)
		//     // let i = 0;
		//     // for(let a of str){
		//     // 	console.log(a)
		//     //     if(a > 0){
		//     //         i++;
		//     //     }
		//     // }
		//     // return i
		//     return str
		// };
		// console.log(hammingWeight(abn));
		
// 5.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

		// 示例 1:

		// 输入: 123
		// 输出: 321
		/**
		 * @param {number} x
		 * @return {number}
		 */
		//  const x = 123;
		//  var reverse = function(x) {
		//       const flag = x > 0 ? '' : '-';
		//       const str = String(x);
		//       const arr = str.split('');
		//       arr.reverse();
		//       const result = parseInt(`${flag}${arr.join('')}`);
		//       if (result <= -Math.pow(2, 31) || result >= Math.pow(2, 31)) return 0;
		//       return result;
		// };
		// console.log(reverse(x));
		
// 6.给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

		// 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

		// 示例 1:
		// 给定数组 nums = [1,1,2], 
		// 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
		// 你不需要考虑数组中超出新长度后面的元素。

		/**
		 * @param {number[]} nums
		 * @return {number}
		 */
		//    var removeDuplicates = function(nums) {
		//     for (let i = 0; i < nums.length; i++) {
		//         if (nums[i + 1]===  nums[i]) {
		//             nums.splice(i + 1, 1)
		//             i--
		//         }
		//     }
		//     return nums.length
		// };

//7.小A 和 小B 在玩猜数字。小B 每次从 1, 2, 3 中随机选择一个，小A 每次也从 1, 2, 3 中选择一个猜。他们一共进行三次这个游戏，请返回 小A 猜对了几次？

		// 输入的guess数组为 小A 每次的猜测，answer数组为 小B 每次的选择。guess和answer的长度都等于3。
		// 示例 1：
		// 输入：guess = [1,2,3], answer = [1,2,3]
		// 输出：3
		// 解释：小A 每次都猜对了。

		/**
		 * @param {number[]} guess
		 * @param {number[]} answer
		 * @return {number}
		 */
		// var game = function(guess, answer) {
		//     let j = 0
//     for(let i = 0; i < 3; i++){
		//         if(guess[i] === answer[i]) j++;
		//     }
		//     return j
		// };

		//一行代码
		//const game = (guess, answer) => guess.filter((x,i) => x === answer[i]).length;

//8.给你一个以行程长度编码压缩的整数列表 nums 。
		// 考虑每对相邻的两个元素 [a, b] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后有 a 个值为 b 的元素。
		// 请你返回解压后的列表。
		
		// 示例：
		// 输入：nums = [1,2,3,4]
		// 输出：[2,4,4,4]
		// 解释：第一对 [1,2] 代表着 2 的出现频次为 1，所以生成数组 [2]。
		// 第二对 [3,4] 代表着 4 的出现频次为 3，所以生成数组 [4,4,4]。
		// 最后将它们串联到一起 [2] + [4,4,4] = [2,4,4,4]。

		// let nums = [1,2,3,4]
		// var decompressRLElist = function(nums) {
		//     let arr = [];
		//     for(let i=0; i< nums.length; i = i+2){
		//         for(let j=0; j<nums[i]; j++){
		//             arr.push(nums[i+1]);
		//         }
		//     }
		// 	return arr
		// };
		// console.log(decompressRLElist(nums));
//9.给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。

	// 示例 1：

	// 输入：n = 234
	// 输出：15 
	// 解释：
	// 各位数之积 = 2 * 3 * 4 = 24 
	// 各位数之和 = 2 + 3 + 4 = 9 
	// 结果 = 24 - 9 = 15

		// var subtractProductAndSum = function(n) {
		// 	let b = n.toString();
		// 	let sum = 0;
		// 	let suu = 1;
		//     for(let i of b ){
		//     	let a = Number(i)
		//         sum = sum + a;
		//         suu = suu * a;
		//     }
		//     return suu - sum
		// };
		// console.log(subtractProductAndSum(n));
		// let arr = [1, 2, 3, 4]
		// console.log(arr.reverse())
//10.给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

// 初始化 A 和 B 的元素数量分别为 m 和 n。

// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/sorted-merge-lcci
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

//第一种方法产生新的数组
		// var merge = function(A, m, B, n) {
		//     const arrA = A.slice(0, m);
		//     const arrB = B.slice(0, n);
		//     let arrC = arrA.concat(arrB);
		//     return arrC.sort();
		// };

		// console.log(merge([1,2,3,0,0,0], 3, [2,5,6], 3));
		/**
		 * @param {number[]} A
		 * @param {number} m
		 * @param {number[]} B
		 * @param {number} n
		 * @return {void} Do not return anything, modify A in-place instead.
		 */
		// var merge = function(A, m, B, n) {
		//     A.splice(m, A.length);
		//     B.splice(n, B.length);
		//     A.push.apply(A, B)
		//     return A.sort((a, b) => a - b);
		// };
// 		console.log(merge([1,2,3,0,0,0], 3, [2,5,6], 3));

	// 1、concat
		// js的Array对象提供了一个叫concat()方法，连接两个或更多的数组，并返回结果。
		// var c = a.concat(b); //c=[1,2,3,4,5,6];
		// 这里有一个问题，concat方法连接a、b两个数组后，a、b两个数组的数据不变，同时会返回一个新的数组。这样当我们需要进行多次的数组合并时，会造成很大的内存浪费，如果是数据量比较小的时候，还可以勉强用，如果数据量大的时候，这个就不妥了，所以这个方法肯定不是最好的。
	// 2、for循环
		// 大概的思路是：遍历其中一个数组，把该数组中的所有元素依次添加到另外一个数组中。直接上代码：
		// for( var i in b)
		// {
		//   a.push(b[i]);
		// }
		// 这样的写法可以解决第一种方案中对内存的浪费，但是会有另一个问题：丑！这么说不是没有道理，如果能只用一行代码就搞定，岂不快哉~
		// var myObject={
		// 　　a:1,
		// 　　b:2,
		// 　　c:3
		// }
		// for (var key in myObject) {
		//   console.log(key);
		// }
	// 3、apply
		// 函数的apply方法有一个特性，那就是func.apply(obj,argv)，argv是一个数组。所以我们可以利用这点，直上代码：
		// a.push.apply(a,b);
		// 调用a.push这个函数实例的apply方法，同时把，b当作参数传入，这样a.push这个方法就会遍历b数组的所有元素，达到合并的效果。
		// 这里可能有点绕，我们可以把b看成[4,5,6]，变成这样：
		// a.push.apply(a,[4,5,6]);
		// 然后上面的操作就等同于：
		// a.push(4,5,6);
		// 这样就很清楚了！
		// 另外，还要注意两个小问题：
		// 1）以上3种合并方法并没有考虑过a、b两个数组谁的长度更小。
		// 所以好的做法是预先判断a、b两个数组哪个更大，然后使用大数组合并小数组，这样就减少了数组元素操作的次数！
		// 2）有时候我们不希望原数组（a、b）改变，这时就只能使用concat了。
		// 以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。

	// 	sort排序


		//     js中用方法sort()为数组排序。sort()方法有一个可选参数，是用来确定元素顺序的函数。如果这个参数被省略，那么数组中的元素将按照ASCII字符顺序进行排序。

		// 例如：

		// 　　var arr = ["a", "b", "A", "B"];
		// 　　arr.sort();
		// 　　console.log(arr);

		// 因为字母A、B的ASCII值分别为65、66，而a、b的值分别为97、98，所以上面输出的结果是 [“A”, “B”, “a”, “b”] 。

		// 当我们对数字进行排序的时候

		// 　　var arr = [15, 8, 25, 3];
		// 　　arr.sort();
		// 　　console.log(arr);

		// 结果是 [15, 25, 3, 8] 。其实，sort方法会调用每个数组项的toString()方法，得到字符串，然后再对得到的字符串进行排序。虽然数值15比3大，但在进行字符串比较时”1”则排在”3”前面。显然，这种结果不是我们想要的，这时，sort()方法的参数就起到了作用，我们把这个参数叫做比较函数。

		// 对数组数字排序用函数来改变，修改方法如下：

		// 　　var arr = [23, 9, 4, 78, 3];
		// 　　var compare = function (x, y) {//比较函数
		// 　　　　if (x < y) {
		// 　　　　　　return -1;
		// 　　　　} else if (x > y) {
		// 　　　　　　return 1;
		// 　　　　} else {
		// 　　　　　　return 0;
		// 　　　　}
		// 　　}
		// 　　console.log(arr.sort(compare)); 

		// 结果为 [3, 4, 9, 23, 78] ，返回了我们想要的结果

		// 如果要按降序排序，比较函数写成这样即可：

		// 　　var compare = function (x, y) {
		// 　　　　if (x < y) {
		// 　　　　　　return 1;
		// 　　　　} else if (x > y) {
		// 　　　　　　return -1;
		// 　　　　} else {
		// 　　　　　　return 0;
		// 　　　　}
		// 　　}

		// 我们还可以对上面的函数进行简化的写法：

		// 　　var arr = [23, 9, 4, 78, 3];
		// 　　　　//升序
		// 　　　　　　arr.sort(function(a,b){
		// 　　　　　　　　retun a-b;
		// 　　　　　　});
		// 　　　　//降序
		// 　　　　　　arr.sort(function(a,b){
		// 　　　　　　　　retun b-a;
		// 　　　　　　});
//11、给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。

		// 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] < nums[i] 。
		// 以数组形式返回答案。
		// 示例 1：
		// 输入：nums = [8,1,2,2,3]
		// 输出：[4,0,1,1,3]
		// 解释： 
		// 对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 
		// 对于 nums[1]=1 不存在比它小的数字。
		// 对于 nums[2]=2 存在一个比它小的数字：（1）。 
		// 对于 nums[3]=2 存在一个比它小的数字：（1）。 
		// 对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。
		//第一种解题方法
		/**
		 * @param {number[]} nums
		 * @return {number[]}
		 */
		// var smallerNumbersThanCurrent = function(nums) {
		//     let n =  0;
		//     let arr = [];
		//     for(let j = 0; j < nums.length; j++){
		//         for(let i = 0; i < nums.length; i++){
		//             if(nums[j] > nums[i]){
		//               n++;
		//             }
		//         }
		//         arr.push(n);
		//         n = 0;
		//     } 
		//     return arr;
		// };
		// console.log(smallerNumbersThanCurrent([8,1,2,2,3]))

		//第二种解题方法
		// var smallerNumbersThanCurrent = function (nums) {
		//     let a = nums.reduce((prev, curr) => {
		//         prev.push(nums.filter(n => n < curr).length)
		//         return prev;
		//     }, [])
		//     return a
		// };
		// console.log(smallerNumbersThanCurrent([8,1,2,2,3]))
		// reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
		// reduce() 可以作为一个高阶函数，用于函数的 compose。
		// 注意: reduce() 对于空数组是不会执行回调函数的。
		// filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
		// 注意： filter() 不会对空数组进行检测。
		// 注意： filter() 不会改变原始数组。

//12.请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

	// 示例 1：

	// 输入：s = "We are happy."
	// 输出："We%20are%20happy."
	/**
	 * @param {string} s
	 * @return {string}
	 */
	// var replaceSpace = function(s) {
	//     return s.replace(/ /g, '%20')
	// };
//13. 给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
	// J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。
	// 示例 1:
	// 输入: J = "aA", S = "aAAbbbb"
	// 输出: 3
		// var numJewelsInStones = function(J, S) {
		//     let j = 0;
		//     for(let i of J){
		//         for(let a of S){
		//             if(i === a){
		//                 j++
		//             }
		//         }
		//     }
		//     return j
		// };

		// var numJewelsInStones = function(J, S) {
		// return S.split('').filter(s => J.includes(s)).length
		// };
//14.给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。
		// 示例 1：
		// 输入：n = 5
		// 输出：[-7,-1,1,3,4]
		// 解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。

		// var sumZero = function(n) {
		//     let arr = new Array(n).fill(0);
		//     let sun = 0;
		//     for(let i=0; i<n-1; i++){
		//         arr[i] =  Math.round(5 - Math.random()*10);
		//         sun = sun + arr[i];
		//     }
		//     arr[n-1] = 0 -  sun;
		//     return arr
		// };
		// console.log(sumZero(5));

		//fill() 方法用于将一个固定值替换数组的元素。

		// 需要了解的 Math 对象方法

		// 方法     				描述
		// ceil(x)			对数进行上舍入，即向上取整。
		// floor(x)		对 x 进行下舍入，即向下取整。
		// round(x)		四舍五入。
		// random()		返回 0 ~ 1 之间的随机数，包含 0 不包含 1。
//15输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
		// 示例 1:
		// 输入: n = 1
		// 输出: [1,2,3,4,5,6,7,8,9]
		// /**
		//  * @param {number} n
		//  * @return {number[]}
		//  */
		// var printNumbers = function(n) {
		//     let arr = []
		//     for(let i=1; i<Math.pow(10, n);i++){
		//         arr.push(i)
		//     }
		//     return arr
		// };


		// pow() 方法可返回 x 的 y 次幂的值。
		// 语法
		// Math.pow(x,y)
		// 参数				描述
		// x			必需。底数。必须是数字。
		// y			必需。幂数。必须是数字。


		// var getDecimalValue = function(head) {
		//     let tatol = 0;
		//     head.map((num, index) =>{
		//     	if(num === 1){
		//        		 tatol += num * Math.pow(2, index);
		//     	}
		//     	console.log(tatol);
		//     })
		//     return tatol
		// };
		// console.log(getDecimalValue([1,0,1]))

		//parseInt(string, radix)
		//string	必需。要被解析的字符串。
		// radix	
		// 可选。表示要解析的数字的基数。该值介于 2 ~ 36 之间。

		// 如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。

		// 如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。

//16. 自除数 是指可以被它包含的每一位数除尽的数。
		// 例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。
		// 还有，自除数不允许包含 0 。
		// 给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。
		// 输入： 
		// 上边界left = 1, 下边界right = 22
		// 输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]

		// var selfDividingNumbers = function(left, right) {
		//     let arr = [];
		//     let num = [];
		    
		//     for(let i=left; i<=right; i++){
		//         arr.push(i);
		//     }
		//     for(let j=0; j<arr.length; j++){
		//     	let karrs =[];
		//         for(let k of arr[j].toString()){
		//         	karrs.push(k);
		//         }
	 //        	let abs = karrs.every(item => {
	 //        		return arr[j]%item == 0
	 //        	})
	 //        	if(abs){
	 //        		num.push(arr[j])
	 //        	}
		//     }
		//     return num
		// };
		// console.log(selfDividingNumbers(1,22))
		// every()与some()方法都是JS中数组的迭代方法。
		// every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。
		// some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。
		// var arr = [ 1, 2, 3, 4, 5, 6 ]; 
		// console.log( arr.some( function( item, index, array ){ 
		//     console.log( 'item=' + item + ',index='+index+',array='+array ); 
		//     return item > 3; 
		// })); 
		// console.log( arr.every( function( item, index, array ){ 
		//     console.log( 'item=' + item + ',index='+index+',array='+array ); 
		//     return item > 3; 
		// }));
		// some一直在找符合条件的值，一旦找到，则不会继续迭代下去。 
		// every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去
// 17.给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。
		// 示例 1:
		// 输入: 5
		// 输出: 2
		// 解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 

		// var findComplement = function(num) {
		//     let arrs = '';
		//     let str = num.toString(2);
		//     for(let i of str){
		//     	console.log(i)

		//         if(i=='1'){
		//             i = '0';
		//         }else{
		//             i = '1';
		//         }
		//          arrs += i;
		//     }
		//     return parseInt(arrs, 2)
		// };

		// console.log(findComplement(5));
//18、给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

		// 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。
		// 注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。
		// 返回词汇表 words 中你掌握的所有单词的 长度之和。
		// 示例 1：
		// 输入：words = ["cat","bt","hat","tree"], chars = "atach"
		// 输出：6
		// 解释： 
		// 可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。
		// var countCharacters = function(words, chars) {
		// 	//字符串的长度
		// 	let numChars = chars.length;
		// 	//拷贝字符串
		// 	let copyChars = chars;
		// 	//用于最后的输出判断是否跳出循环
		// 	let dapCirculate = 0;
		// 	// 最后的输出结果
		// 	let nums = 0;
		// 	// 循环数组
		//     for(let i=0; i<words.length; i++){
		//     	//重置字符串
		//     	chars = copyChars;
		//     	//重置跳出
		//     	dapCirculate = 0;
		//     	//内在逻辑当一个字符串的字符数到户大于chars的字符串长度那么就一定不会是所熟记的单词
		//     	if(words[i].length <  numChars){
		//     		for(let j of words[i]){
		// 	            if(chars.indexOf(j) == -1){
		// 	            		dapCirculate = 1;
		// 		                break
		// 		            }else {
		// 		            	//截取单词的循环的独立的字符
		// 		                chars = chars.substring(0, chars.indexOf(j)) + chars.substring(chars.indexOf(j)+1)
		// 		            }
		// 		        }
		// 		        // 进行判断1、chars 的长度等于单词的长度并且截取之后的字符为零且跳出循环。2、当截取之后chars里还有字符串且跳出循环那么判断成立
		// 		        if((numChars === words[i].length && chars.length == 0) && dapCirculate !== 1 || chars.length > 0 && dapCirculate !== 1){
		// 		            nums += words[i].length
		// 		        }
		// 	    }
		//     }
		//     return nums
		// };
		// console.log(countCharacters(["cat","bt","hat","tree"],"atach"))

//19.给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
		// 示例:
		// 输入: 38
		// 输出: 2 
		// 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
		// var addDigits = function(num) {
		//     let nums = 0;
		//     let numStr = num.toString();
		//     for(let i of numStr){
		//         nums += Number(i);
		//     }
		//     if(nums >= 10){
	 //          	return addDigits(nums);
	 //        }else{
	 //            return nums

	 //        } 
		// };
		// console.log(addDigits(38))

		//重点问题就是递归函数的调用需要在递归函数之前加入return才能够结束递归函数

		// var uniqueOccurrences = function(arr) {
		// 	debugger
		//     let arrs = arr.filter(item => {
		//         return item > 1 
		//     })
		//     console.log(arrs)
		//     return arrs
		   
		// };
		// console.log(uniqueOccurrences([1,2,2,1,1,3]))
//20
		// var CheckPermutation = function(s1, s2) {
		//     let s3 = s1.split('').sort()
		//     let s4 = s2.split('').sort()
		//     console.log(s3,s4)
		//         if(s3.length !== s4.length){
		//             return false
		//         }else{
		//             for(let i=0; i< s3.length; i++){
		//                 if(s3[i] !== s4[i]){
		//                     return false
		//                 }
		//             }
		//             return true
		//         }
		// };
		// console.log(CheckPermutation("abc","bca"))

// var removeElement = function(nums, val) {
//     let num = nums.filter(item => {
//         return item !== val;
//     })
//     return num
// };
// console.log(removeElement([3,2,2,3],
// 3))

// var removeElement = function(nums, val) {
//     for(let i=0;i<nums.length; i++){
//     	debugger
//         if(nums[i] === val){
//             nums.splice(i,1)
//             i--     //因为当你每次spice的时候如果两个相同的元素相邻那么将会漏掉后边的哪一个因为后边的索引值会向前移动
//         }
//     }
//     console.log(nums)
//     return nums.length
// }
// console.log(removeElement([0,1,2,2,3,0,4,2],
// 2))
// 22.给定两个字符串 s 和 t，它们只包含小写字母。
		// 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。
		// 请找出在 t 中被添加的字母。
		// 示例:
		// 输入：
		// s = "abcd"
		// t = "abcde"
		// 输出：
		// e
// var findTheDifference = function(s, t) {
//    let arrs = s.split('').sort();
//     let arrt = t.split('').sort();
//     for(let i= 0; i<arrt.length;i++){
//         if(arrs[i]!==arrt[i]){
//             return arrt[i]
//         }
//     }
// };
// console.log(findTheDifference("abcd","abcde"))



// var romanToInt = function(s) {
//     let num = null;
//     let orderList = {
//         I:1,
//         V :5,
//         X:10,
//         L:50,
//         C:100,
//         D:500,
//         M:1000
//     }
//     debugger
//    let arrs = s.split('').map(item =>{ return orderList[item]});
//     arrs.forEach(arr => { num += arr})
//     return num
// };
// console.log(romanToInt("III"))
// 21//验证关于数据结构中未赋值的数据显示的值是undefined
		// let [a, b, c] = [1,2]
		// console.log( c===undefined)
 //22、进行验证左移和右移
	 // var a = -14
	 //  a >>= 2
	 // console.log(a)

//23、验证for的无限循环
// var a = 0;
// for (;;){
// 	doSomething()
// }
// console.log(a)
// let arrs = {}
// console.log(arrs == undefined )
/*
 *23、关于给定年月日推算时间是星期几的组件
 *@param day（number） 天 month 月 year 年 typeAll（（number））
 *@return string
 */
// var dayOfTheWeek = function(day, month, year) {
// 	 const date = new Date(`${year}-${month}-${day}`);
//     const weeks = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
//     return weeks[date.getDay()];
// };
// console.log(dayOfTheWeek(8,8,2019))
//24、测试调用函数运行的时间函数
// function f(){
// 	for(let i= 0; i<10000000; i++){}
// }
//在函数前后加上两个date变量就会返回函数的运行时间
const dateDayStart = +new Date()
// dayOfTheWeek(31,8,2019)
// f();
// const dateDayEnd = +new Date()
// let result =  dateDayEnd - dateDayStart
// console.log(result)

//25.桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。
// 示例 1：
// 输入：[4,2,1]
// 输出：4
// 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。
/**
 * @param {number[]} coins
 * @return {number}
 */
//  var minCount = function(coins) {
//     let arrs = coins.map(item =>{
//         if(item%2 === 0){
//             return item/2
//         }else{
//             return Math.ceil(item/2)
//         }
//     })
//     return arrs.reduce((pre, next) => {
//         return pre + next;
//     })
// };

//26给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。
// 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。
// 示例 1：
// 输入：candies = [2,3,5,1,3], extraCandies = 3
// 输出：[true,true,true,false,true] 
// 解释：
// 孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。
// 孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
// 孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。
// 孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。
// 孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。
/**
 * @param {number[]} candies
 * @param {number} extraCandies
 * @return {boolean[]}
 */
// var kidsWithCandies = function(candies, extraCandies) {
// 	const  max  = Math.max(...candies)
//    return candies.map(item => {
//        if(item + extraCandies >=max ){
//            return true
//        }else {
//            return false
//        }
//    })
// };
// console.log(kidsWithCandies([2,3,5,1,3],3))
//27给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。
// 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。
// 示例 1：
// 输入：n = 4
// 输出："pppz"
// 解释："pppz" 是一个满足题目要求的字符串，因为 'p' 出现 3 次，且 'z' 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如："ohhh" 和 "love"。
// var generateTheString = function(n) {
//     if(n===0)return '';
//     if(n===1)return 'a';
//     let res = '';
//     if (n % 2 === 0){
//         res += 'b';
//         for(let i = 1; i <= n-1; i++){
//             res += 'a';
//         }
//     }else{
//         for(let i = 1; i <= n; i++){
//             res += 'a';
//         }
//     }
//     return res;
// };
//28给你一个仅由数字 6 和 9 组成的正整数 num。
// 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。
// 请返回你可以得到的最大数字。
// 示例 1：

// 输入：num = 9669
// 输出：9969
// 解释：
// 改变第一位数字可以得到 6669 。
// 改变第二位数字可以得到 9969 。
// 改变第三位数字可以得到 9699 。
// 改变第四位数字可以得到 9666 。
// 其中最大的数字是 9969 。
/**
 * @param {number} num
 * @return {number}
 */
//  var maximum69Number  = function(num) {
// 	 const nums = num.toString();
//     const arrs  = [];
//     for(let i = 0; i<nums.length; i++ ){
// 		debugger
// 		const a = nums.substring(0,i);
// 		const b = nums.substring(i+1);
// 		const ab = `${a}9${b}`;
//         arrs.push(parseInt(ab))
//     }
//    return  Math.max(...arrs)
// };
// console.log(maximum69Number(9669),'13')
//29给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
// 说明：
// 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
// 示例 1:
// 输入: [2,2,1]
// 输出: 1
/**
 * @param {number[]} nums
 * @return {number}
 */
//  var singleNumber = function(nums) {
//     let num = nums.sort()
//     for(let i=0;i<num.length; i++){
//         if(nums[i]!==num[i+1] && num[i]!==num[i-1] ){
//             return num[i];
//         }
//     }
// };
//30你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。
// 你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。
// 示例:
// 输入: 4
// 输出: false 
// 解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
//      因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
/**
 * @param {number} n
 * @return {boolean}
 */
//  var canWinNim = function(n) {
//      return n%4;
// };
//错误解析如果是5快的话自己可以先取一块剩下的就是你自己的

// var intersection = function(nums1, nums2) {
//     const arrs =[];
// 	debugger
//     const arr1 = Array.from(new Set(nums1));
// 	console.log(arr1)
//     const arr2 = Array.from(new Set(nums2));
//     for(let i=0;i<arr1.length;i++){
//         for(let j=0;j<arr2.length;j++){
//             if(arr1[i]===arr2[j]){
//                 arrs.push(arr1[i])
//             }
//         }

//     }
// return arrs

// };
// console.log(intersection([1,2,2,1],[2,2]))
// var minSubsequence = function(nums) {
//         var arrsNum = nums.sort((a,b)=>{return b-a});
// 		let arrsA =[];
// 		let sumA = null;
//         for(let i=0;i<arrsNum.length;i++){
//             arrsA.push(arrsNum[i])
//             sumA += arrsNum[i]
// 		let sumB = null;
//             for(let j=i+1;j<arrsNum.length;j++){
//                 sumB += arrsNum[j]   
//             }
// 			if(sumA>sumB){
//                  return arrsA
//                 }
//         }
// };
// console.log(minSubsequence([4,3,10,9,8]))
//31给定键盘使用判断
// 	var findWords = function(words) {
// 		let arrs =[];
// 		const arr1 = 'qwertyuiop';
// 		const arr2 = 'asdfghjkl'
// 		const arr3 = 'zxcvbnm'
// 		for(let i=0; i<words.length; i++){
// 			debugger
// 			let arr4 = Array.from(new Set(words[i].toLowerCase().split(""))).sort();
// 		if(arr4.every(item =>{return arr1.includes(item)}) ||arr4.every(item =>{return arr2.includes(item)})||arr4.every(item =>{return arr3.includes(item)}) ){
// 			arrs.push(words[i])
// 		}
// 		}
// 		return arrs
// 	};
// console.log(findWords(["a","b"]))

// var hammingWeight = function(n) {
// 	let i = 0
// 	debugger
//     const arrs = n.toString()
// 	for(let j of arrs){
// 		if(j ==='1'){
// 			i++
// 		}
// 	}
// 	debugger
//     return i
// };
// console.log(hammingWeight(00000000000000000000000000001011))

// var minStartValue = function(nums) {
// 		let abs = nums.length
//         for(let j =0; j<10000000000000000000; j++){
// 				if(nums.length>abs ){
// 					nums.shift();
// 				}
//                nums.unshift(j)
// 			  let  sum =0
// 			  let arrs =[];
//                for(let i=0; i<nums.length; i++){ 
//                    sum =sum + (nums[i])
//                    arrs.push(sum)
//                }
//                if(arrs.every(item=>{return item>0}) && arrs.some(item=> {return item===1 })){
//                    return j
//                }
//         }
// };
// console.log(minStartValue([-3,2,-3,4,2]))

// var abs = function(nums){
// 	const str = nums.toString();
// 	if(str.indexOf(".") ===-1 ){
// 		return `0%`
// 	}else{
// 		const strNum = str.indexOf(".")+1
// 		let strNM = str.substring(strNum)
// 		switch(strNM.length){
// 			case 1:
// 			strNM = `${strNM}0%` 
// 			break;
// 			case 2:
// 			strNM = `${strNM}%` 
// 			break;
// 			default:
// 			strNM = `${strNM.substr(0,2)}.${strNM.substring(2)}%`
// 			break;
// 		}
// 		return strNM
// 	}
// }
// console.log(abs(0))
	// 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。
	// 请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。
	// 示例 1：
	// 输入：nums = [2,5,1,3,4,7], n = 3
	// 输出：[2,3,5,4,1,7] 
	// 解释：由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]
	/**
 * @param {number[]} nums
 * @param {number} n
 * @return {number[]}
 */
// var shuffle = function(nums, n) {
//     const arr1 = nums.slice(0,n);
//     const arr2 = nums.slice(n);
//     const arr = []
//     for(let i=0;i<n; i++){
//             arr.push(arr1[i])
//             arr.push(arr2[i])
//         }
//     return arr

// };

// 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。
// 示例 1:
// 输入: 121
// 输出: true
/**
 * @param {number} x
 * @return {boolean}
 */
//  var isPalindrome = function(x) {
// 	 const str = x.toString()
//     const arr1 = str.split('');
//     const arr2 = str.split('').reverse();
//     const arr3 =[]
//     for(let i=0; i<str.length; i++){
//         arr3.push(arr1[i] === arr2[i])
//     }
//     return arr3.every(item =>{return item ===true})
// };
// var isPalindrome = function(x) {
// 	 const str = x.toString()
//     const arr = str.split('').reverse().join('');
// 	return str===arr
// };
// console.log(isPalindrome(-121))
// 1464. 数组中两元素的最大乘积
// 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。
// 请你计算并返回该式的最大值。
// 示例 1：
// 输入：nums = [3,4,5,2]
// 输出：12 
// 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 
//  */
//  var maxProduct = function(nums) {
//     let [a,b,...num] = nums.sort((a,b)=> b-a);
// 	debugger
//     return (a-1)*(b-1)
// };
// console.log(maxProduct([3,4,5,2]))
// 1460. 通过翻转子数组使两个数组相等
// 给你两个长度相同的整数数组 target 和 arr 。
// 每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。
// 如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。
// 示例 1：
// 输入：target = [1,2,3,4], arr = [2,4,1,3]
// 输出：true
// 解释：你可以按照如下步骤使 arr 变成 target：
// 1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]
// 2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]
// 3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]
// 上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。
/**
 * @param {number[]} target
 * @param {number[]} arr
 * @return {boolean}
 */
//  var canBeEqual = function(target, arr) {
//     return target.sort().toString()===arr.sort().toString()
// };
// 852. 山脉数组的峰顶索引
// 我们把符合下列属性的数组 A 称作山脉：

// A.length >= 3
// 存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
// 给定一个确定为山脉的数组，返回任何满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。

// 示例 1：
// 输入：[0,1,0]
// 输出：1
// 示例 2：
// 输入：[0,2,1,0]
// 输出：1
// var peakIndexInMountainArray = function(A) {
// 	let B = [...A]
// 	const number = B.sort((a,b)=>a-b)[A.length-1];
//     return A.findIndex((item) =>{return item ===number})
// };
// console.log(peakIndexInMountainArray([0,10,5,2]))




// 1480. 一维数组的动态和
// 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
// 请返回 nums 的动态和。
// 示例 1：
// 输入：nums = [1,2,3,4]
// 输出：[1,3,6,10]
// 解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
/**
 * @param {number[]} nums
 * @return {number[]}
 */
//  var runningSum = function(nums) {
//     let arrs = [];
//     for(let i =0;i<nums.length;i++){
// 		let sum = 0;
//         for(let j=0;j<=i;j++){
//             sum += nums[j] 
//         }
//          arrs.push(sum)
//     }
// 	return arrs 
// };
// console.log(runningSum([1,2,3,4]))
// 832. 翻转图像
// 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。
// 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。
// 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。
// 示例 1:
// 输入: [[1,1,0],[1,0,1],[0,0,0]]
// 输出: [[1,0,0],[0,1,0],[1,1,1]]
// 解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
//      然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
//  var flipAndInvertImage = function(A) {
//     let arrs = []
//     let B =[]
//     for(let i=0;i<A.length;i++){
//         let B = A[i].reverse().map(item=>{ if(item ===1){
//             return item = 0
//         }else{
//             return item = 1
//         }
//         })
//         arrs.push(B)
//     }
//     return arrs
// };

/* 1389. 按既定顺序创建目标数组
给你两个整数数组 nums 和 index。你需要按照以下规则创建目标数组：

目标数组 target 最初为空。
按从左到右的顺序依次读取 nums[i] 和 index[i]，在 target 数组中的下标 index[i] 处插入值 nums[i] 。
重复上一步，直到在 nums 和 index 中都没有要读取的元素。
请你返回目标数组。
题目保证数字插入位置总是存在。
示例 1：
输入：nums = [0,1,2,3,4], index = [0,1,2,2,1]
输出：[0,4,1,3,2]
解释：
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2] */

/**
 * @param {number[]} nums
 * @param {number[]} index
 * @return {number[]}
 */
// var createTargetArray = function(nums, index) {
//     let returnArr = [];
//     for(let i = 0;i<index.length;i++){
//     returnArr.splice( index[i],0,nums[i])
//     }
//     return returnArr
// };
// 1550. 存在连续三个奇数的数组
// 给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。

 
// var threeConsecutiveOdds = function(arr) {
//     const booleanArrs = []
//     for(let i = 0; i<arr.length;i++){
//         if(arr[i]%2 === 1 && arr[i+1]%2 === 1&&arr[i+2]%2 === 1){
//            booleanArrs.push(true)
//         }else{
//             booleanArrs.push(false)
//         }
//     }
//     return booleanArrs.some(item => item === true)
// };
// console.log(threeConsecutiveOdds([1,2,34,3,4,5,7,23,12]))

// 1512. 好数对的数目
// 给你一个整数数组 nums 。

// 如果一组数字 (i,j) 满足 nums[i] == nums[j] 且 i < j ，就可以认为这是一组 好数对 。

// var numIdenticalPairs = function(nums) {
//     const arrs = []
// 	debugger
//     for(let i=0;i<nums.length;i++){
//         for(let j=i+1; j<nums.length;j++){
//             if(nums[i]===nums[j] && i<j){
//                 arrs.push(i)
//             }

//         }

//     }
//     return arrs.length

// };
// console.log(numIdenticalPairs([1,2,3,1,1,3]))
// 1528. 重新排列字符串
// 给你一个字符串 s 和一个 长度相同 的整数数组 indices 。

// 请你重新排列字符串 s ，其中第 i 个字符需要移动到 indices[i] 指示的位置。

// 返回重新排列后的字符串。

// var restoreString = function(s, indices) {
// 	debugger
//     const strArrs =[...s];

//     const strArrsIn = [];
//     for(let i=0;i<indices.length;i++){
	
//        strArrsIn[indices[i]] =  strArrs[i]
	  
//     }
//     return strArrsIn.join('')

// };	
// console.log(restoreString("codeleet",[4,5,6,7,0,2,1,3]))

// 905. 按奇偶排序数组
// 给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。

// 你可以返回满足此条件的任何数组作为答案。

 

// 示例：

// 输入：[3,1,2,4]
// 输出：[2,4,3,1]
// 输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
// var sortArrayByParity = function(A) {
//     const secendArrs = [];
//     const firstArrs = [];
//     A.forEach(item => {if(item%2===0) {return secendArrs.push(item)}else{firstArrs.push(item)}});
//     return [...secendArrs,...firstArrs]

// };
// 1047. 删除字符串中的所有相邻重复项
// 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
// 在 S 上反复执行重复项删除操作，直到无法继续删除。
// 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
// 示例：
// 输入："abbaca"
// 输出："ca"
// 解释：
// 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
/**
 * @param {string} S
 * @return {string}
 */
//  var removeDuplicates = function(S) {
//     let stack = []
//     for(c of S) {
//         let prev = stack.pop()
//         if(prev !== c) {
//             stack.push(prev)
//             stack.push(c)
//         }
//     }
//     return stack.join('')
// };
// 面试题 08.03. 魔术索引
// 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

// 示例1:

//  输入：nums = [0, 2, 3, 4, 5]
//  输出：0
//  说明: 0下标的元素为0
/**
*@description 此函数时间和占用内存最小的方法
*@param nums [Array]
*@return Number 
 */
// var findMagicIndex = function(nums) {
// 	let arrs =[]
// 	for(let i=0;i<nums.length;i++){
// 		if(nums[i]=== i){
// 			arrs.push(i)
// 		}
// 	}
// 		if(arrs.length){
// 			return arrs[0]
// 		}else{
// 			return -1
// 		}
// };
/**
*@description 此函数是最简洁的方法一步到位
*@param nums [Array]
*@return Number 
 */
// var findMagicIndex = function(nums) {
//  return nums.findIndex((v, i) => v === i)
// };
// console.log(findMagicIndex([0, 2, 3, 4, 5]))

// 面试题 01.02. 判定是否互为字符重排
// 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

// 示例 1：

// 输入: s1 = "abc", s2 = "bca"
// 输出: true 
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
//  var CheckPermutation = function(s1, s2) {
// 		   return  s1.split('').sort().join()=== s2.split('').sort().join(); 
// 		};
// 371. 两整数之和
// 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
// 示例 1:
// 输入: a = 1, b = 2
// 输出: 3
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
//  var getSum = function(a, b) {
//     return [a,b].reduce((pre,cur)=>{return pre+cur})
// };
// 1. 两数之和
// 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
// 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
// 示例:
// 给定 nums = [2, 7, 11, 15], target = 9
// 因为 nums[0] + nums[1] = 2 + 7 = 9
// 所以返回 [0, 1]
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
//  var twoSum = function(nums, target) {
//     let arrs =[];
// 	debugger
//     for(let i=0;i<nums.length; i++){
//         for(let j=0;j<nums.length; j++){
//             if((nums[i] + nums[j]) === target && i!==j){
// 				debugger
//                 arrs.push(i);
//                 arrs.push(j); 
// 				return arrs
//             }
//         }

//     }
    
// };
// console.log(twoSum([2,7,11,15],9))
// 7. 整数反转
// 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
// 示例 1:
// 输入: 123
// 输出: 321
// var reverse = function(x) {
//     let str = String(x);
// 	debugger
//     if(str.indexOf('-') === -1){
// 		str = Number(str.split('').reverse().join(''));
//     }else{
		
// 		 str = Number('-'+ str.substr(1).split('').reverse().join(''));
// 	}
// 	if(str > Math.pow(2,31) || str < -Math.pow(2,31)){
// 		return 0
// 	}
// 	return str 
// };
// console.log(reverse(-321))

// 58. 最后一个单词的长度
// 给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。
// 如果不存在最后一个单词，请返回 0 。
// 说明：一个单词是指仅由字母组成、不包含任何空格字符的 最大子字符串。
// 示例:
// 输入: "Hello World"
// 输出: 5
// var lengthOfLastWord = function(s) {
// 	if(s === ''){
// 		return 0
// 	}
//     let arrs = [];
// 	let arrsCpay = []
	
//     if(s.indexOf(' ') !== -1 && s){
//         arrs = s.split(' ')
// 		for(let i = 0;i<arrs.length; i++){
// 			if(arrs[i]){
// 				arrsCpay.push(arrs[i])
// 			}
// 		}
//         if(arrsCpay.length === 1){
//             return arrsCpay[0].length
//         }else if(arrsCpay.length === 0){
// 			return 0
// 		}else{
//             return arrsCpay[arrsCpay.length-1].length
//         }
//     }else if(s.indexOf(' ') === -1 && s){
//         return s.length
//     }
// };
// console.log(lengthOfLastWord(" "))

//优化先取出字符串前后的空字符
// var lengthOfLastWord = function(s) {
// s = s.trim();
// let arr = s.split(" ");
// return arr[arr.length-1].length
// };

// 202. 快乐数
// 编写一个算法来判断一个数 n 是不是快乐数。
// 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。
// 如果 n 是快乐数就返回 True ；不是，则返回 False 。
// 示例：
// 输入：19
// 输出：true
// 解释：
// 12 + 92 = 82
// 82 + 22 = 68
// 62 + 82 = 100
// 12 + 02 + 02 = 1
// var isHappy = function(n,arrs1 =[]) {
// 	debugger
// 	let a = 0
//     let arrs = String(n).split('');
//     let arrsCopy = arrs.map(item=> Number(item)*Number(item)).reduce((prv,cvr)=>prv+cvr);
// 	if(arrsCopy === 1){
// 		return true 
// 	}else{
// 		if(arrs1.includes(arrsCopy)){
// 			return false
// 		}else{
// 			arrs1.push(arrsCopy)
// 		}
// 	return 	isHappy(arrsCopy,arrs1);
// 	}
// };	
// console.log(isHappy(2))

// 189. 旋转数组
// 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
// 示例 1:
// 输入: [1,2,3,4,5,6,7] 和 k = 3
// 输出: [5,6,7,1,2,3,4]
// 解释:
// 向右旋转 1 步: [7,1,2,3,4,5,6]
// 向右旋转 2 步: [6,7,1,2,3,4,5]
// 向右旋转 3 步: [5,6,7,1,2,3,4]
// var rotate = function(nums, k) {
//     const strsub = nums.splice(nums.length-k);
//     return [...strsub,...nums];

// };
// var rotate = function(nums, k) {
// debugger
//     for(let i=0;i<k;i++){
//          const strsub = nums.splice(nums.length-1);
//         nums.unshift(strsub[0])
//     }
// 	return nums;
// };
// console.log(rotate([1,2,3,4,5,6,7],3))

// 557. 反转字符串中的单词 III
// 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
// 示例：
// 输入："Let's take LeetCode contest"
// 输出："s'teL ekat edoCteeL tsetnoc"
// var reverseWords = function(s) {
// 	debugger
//     let arrs =s.split(' ');
//     let str = '';
//     for(let i=0; i<arrs.length;i++){
//         str += i===arrs.length-1?arrs[i].split('').reverse().join(''):arrs[i].split('').reverse().join('') + ' ';
//     }
//     return str
// };
// console.log(reverseWords("Let's take LeetCode contest"))
// 14. 最长公共前缀
// 编写一个函数来查找字符串数组中的最长公共前缀。
// 如果不存在公共前缀，返回空字符串 ""。
// 示例 1:
// 输入: ["flower","flow","flight"]
// 输出: "fl"
// var longestCommonPrefix = function(strs) {
// 	debugger
//     if(strs.some(item =>{return item ===''}) || strs.length === 0){
//         return ''
//     }
//     if(strs.length === 1){
//         return strs[0]
//     }
//     for(let i=0;i<strs[0].split('').length;i++){
//         let string = strs[0].substring(0,i+1)
// 		if(strs.every(item => {return item.substring(0,i+1) === strs[0]})){
// 			return strs[0]
// 		}
//         if(strs.every(item => {return item.substring(0,i+1)=== string}) === false){
//             if(string.length ===0 ){
//                 return ''
//             }else{
//                return strs[0].substring(0,i) 
//             }
//         }
//     }
// };
// console.log(longestCommonPrefix(["c","acc","ccc"]))

// 20. 有效的括号
// 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
// 有效字符串需满足：
// 左括号必须用相同类型的右括号闭合。
// 左括号必须以正确的顺序闭合。
// 注意空字符串可被认为是有效字符串。
// 示例 1:
// 输入: "()"
// 输出: true
// var isValid = function(s) {
//     const leftRightMap = {
//         '(': ')',
//         '[': ']',
//         '{': '}'
//     }
//     // 左括号数组
//     const lefts = [];
//     for (let curSymbol of s) {
//         if (['(', '[', '{'].includes(curSymbol)) {
//             lefts.push(curSymbol); 
//         } else {
//             const leftSymbol = lefts.pop();
//             let rightExpectSymbol = leftRightMap[leftSymbol];
//             if (curSymbol !== rightExpectSymbol) {
//                 return false; 
//             }
//         }
//     }
//     return lefts.length === 0;
// };
// 1446. 连续字符
// 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。
// 请你返回字符串的能量。
// 示例 1：
// 输入：s = "leetcode"
// 输出：2
// 解释：子字符串 "ee" 长度为 2 ，只包含字符 'e' 。
// var maxPower = function (s) {
//       let reg = /(\w)\1*/g;
//       return s.match(reg).sort((a,b)=>b.length-a.length)[0].length;
//     };

// 70. 爬楼梯
// 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
// 注意：给定 n 是一个正整数。
// 示例 1：
// 输入： 2
// 输出： 2
// 解释： 有两种方法可以爬到楼顶。
// 1.  1 阶 + 1 阶
// 2.  2 阶
/**
 * @param {number} n
 * @return {number}
 */
 //菲波那切数列
//  var climbStairs = function(n) {
//   if(n===1) return 1
//   let f = 1, s = 2
//   for(let i = 3; i <= n; i++) {
//     let t = f + s
//     f = s
//     s = t
//   }
//   return s
// };
// var average = function(salary) {
//     const maxNumber = Math.max(...salary);
//     const minNumber = Math.min(...salary);
// 	debugger
//     const maxIndex = salary.findIndex(item =>  item === maxNumber);
//     salary.splice(maxIndex,1)
//     const minIndex = salary.findIndex(item =>  item === minNumber);
//     salary.splice(minIndex,1)
//     return salary.reduce((pre,cry)=>{
//         return pre + cry
//     })/salary.length

// };
// 	var average = function(salary) {
// 		const array = salary.sort((a,b)=> a-b)
// 		const spliceArray = array.slice(1,array.length-1)
// 		return spliceArray.reduce((pre,cry)=>{
// 			return pre + cry
// 		})/spliceArray.length

// 	};
// console.log(average([25000,48000,57000,86000,33000,10000,42000,3000,54000,29000,79000,40000]))

// 67. 二进制求和
// 给你两个二进制字符串，返回它们的和（用二进制表示）。
// 输入为 非空 字符串且只包含数字 1 和 0。
// 示例 1:
// 输入: a = "11", b = "1"
// 输出: "100"
// var addBinary = function(a, b) {
//     return (BigInt('0b' + a) + BigInt('0b' + b)).toString(2);
// };


// console.log(addBinary("10100000100100110110010000010101111011011001101110111111111101000000101111001110001111100001101","110101001011101110001111100110001010100001101011101010000011011011001011101111001100000011011110011"))
// 1009. 十进制整数的反码
// 每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。

// 二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 "101" 的二进制反码为 "010"。

// 给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。
// 示例 1：
// 输入：5
// 输出：2
// 解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。
// var bitwiseComplement = function(N) {
//    let a =  N.toString(2);
//    let asrr =[];
//    for(let j of a){
// 	j==='1'? asrr[asrr.length] = 0:  asrr[asrr.length] = 1 
//    }
//    return parseInt(asrr.join(''),2)
// };
// console.log(bitwiseComplement(5))
// 387. 字符串中的第一个唯一字符
// 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
// 示例：
// s = "leetcode"
// 返回 0
// s = "loveleetcode"
// 返回 2
// var firstUniqChar = function(s) {
// 	debugger
//     let arrs=s.split('');
//     let objectArrs = arrs.reduce((pre,next)=>{
// 		debugger
//        pre[next] =  (pre[next]+1) || 1;
//        return pre
//     },{})
//     let arrs2 = []
//     for(let j in objectArrs){
//         if(objectArrs[j]===1){
//             arrs2[arrs2.length] = j
//         }
//     }
//     return s.indexOf(arrs2[0])
// };

// var firstUniqChar = function(s) {
//     for (let i = 0; i < s.length; i++) {
//         if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
//             return i
//         }
//     }
//     return -1
// };
// console.log(firstUniqChar("leetcode"))

// 448. 找到所有数组中消失的数字
// 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
// 找到所有在 [1, n] 范围之间没有出现在数组中的数字。
// 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
// 示例:
// 输入:
// [4,3,2,7,8,2,3,1]
// 输出:
// [5,6]
// var findDisappearedNumbers = function(nums) {
//     let arrs = [];
//     let arrsStr = Math.max(...nums)>nums.length? Math.max(...nums):nums.length
//     for(let i=1;i<=arrsStr;i++){
//         if(!nums.includes(i)){
//             arrs[arrs.length] = i
//         }
//     }
//     return arrs
// };
// 1089. 复写零
// 给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。
// 注意：请不要在超过该数组长度的位置写入元素。
// 要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。
// 示例 1：
// 输入：[1,0,2,3,0,4,5,0]
// 输出：null
// 解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
// var duplicateZeros = function(arr) {
// let leng = arr.length
// 	if(arr.legnth<=1){
// 		return []
// 	}
// for(let i=0;i<arr.length;i++){
// 	if(i>=leng){
// 		return arr.splice(leng)
// 	}
// 	if(arr[i]==0){
// 		arr.splice(i,0,0)
// 		i++
// 	}
// }
// return arr.splice(leng)
// };
// var intersect = function(nums1, nums2) {
// let arrs = []
//     for(let i=0; i<nums1.length; i++){
// 		debugger
//         if(nums2.includes(nums1[i])){
//             arrs.push(nums1[i]);
//          nums1.splice(i,1);
// 		 for(let j=0;j<nums2.length;j++){
// 			if(nums1[i]===nums2[j]){
//            		 nums2.splice(j,1)
// 			}
// 			break
// 		 }
// 		 i--;
//         }
//     }
//     return arrs

// };

// console.log(intersect([1,2,2,1],[2,2]))
// 给定一个单词，你需要判断单词的大写使用是否正确。

// 我们定义，在以下情况时，单词的大写用法是正确的：

// 全部字母都是大写，比如"USA"。
// 单词中所有字母都不是大写，比如"leetcode"。
// 如果单词不只含有一个字母，只有首字母大写， 比如 "Google"。
// 否则，我们定义这个单词没有正确使用大写字母。

// 示例 1:

// 输入: "USA"
// 输出: True

// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/detect-capital
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
// var detectCapitalUse = function(word) {
//     let arrs = word.split('')
//     let english = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
// debugger
//     if(arrs.every(item => english.includes(item))){
//         return true
//     }
//     if(arrs.every(item => english.toLowerCase().includes(item))){
//         return true
//     }
//     let startString = word.substr(0,1)
//     let arrs2 = arrs.splice(1)
//     if(english.includes(startString) && arrs2.every(item => english.toLowerCase().includes(item))){
//         return true
//     }
//     return false 
// };
// console.log(detectCapitalUse("FlaG"))
// 1287. 有序数组中出现次数超过25%的元素
// 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。
// 请你找到并返回这个整数
// 示例：
// 输入：arr = [1,2,2,6,6,6,6,7,10]
// 输出：6
// var findSpecialInteger = function(arr) {
//     let arrObject = arr.reduce((pre,next)=>{
// 		debugger
//         pre[next] =  (pre[next] + 1) || 1 ;
// 		console.log(pre)
//         return pre
//     },{})
//     for(let i in arrObject){
//          if( arrObject[i]>arr.length/4) return i;
//     }

// };
// console.log(findSpecialInteger([1,2,2,6,6,6,6,7,10]))
// 434. 字符串中的单词数
// 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。
// 请注意，你可以假定字符串里不包括任何不可打印的字符。
// 示例:
// 输入: "Hello, my name is John"
// 输出: 5
// 解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
// /**
//  * @param {string} s
//  * @return {number}
//  */
//  var countSegments = function(s) {
//      return s.split(" ").filter((item) => item !== "").length;
// };
// 1408. 数组中的字符串匹配
// 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
// 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。
// 示例 1：
// 输入：words = ["mass","as","hero","superhero"]
// 输出：["as","hero"]
// 解释："as" 是 "mass" 的子字符串，"hero" 是 "superhero" 的子字符串。
// ["hero","as"] 也是有效的答案。
/**
 * @param {string[]} words
 * @return {string[]}
 */
//  var stringMatching = function(words) {
//     let arrs=[]
//     for(let i=0;i<words.length;i++){
//         for(let j=0;j<words.length;j++){
//         if(words[i].includes(words[j]) && words[i]!==words[j]){
//             arrs[arrs.length] = words[j]
//         }

//     }

//     }
//     return Array.from(new Set(arrs))
// };
// 剑指 Offer 58 - I. 翻转单词顺序
// 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。
// 示例 1：d
// 输入: "the sky is blue"
// 输出: "blue is sky the"
// var reverseWords = function(s) {
//  return  s.trim().split(' ').filter(item => item !== "").reverse().join(" ")
// };
// console.log(reverseWords("a good   example"))
// 884. 两句话中的不常见单词
// 给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）
// 如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。
// 返回所有不常用单词的列表。
// 您可以按任何顺序返回列表。
// 示例 1：
// 输入：A = "this apple is sweet", B = "this apple is sour"
// 输出：["sweet","sour"]
// var uncommonFromSentences = function(A, B) {
//     let arr3 = [...A.split(" "),...B.split(" ")].reduce((pre,item)=>{
//         pre[item] = (pre[item]+1) || 1;
//         return pre
//     },{})
//     let arrs =[]
//     for(let i in arr3){
//         if(arr3[i]===1){
//             arrs[arrs.length] = i
//         }
//     }
//     return arrs
// };
// 69. x 的平方根
// 实现 int sqrt(int x) 函数。
// 计算并返回 x 的平方根，其中 x 是非负整数。
// 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
// 示例 1:
// 输入: 4
// 输出: 2
// var mySqrt = function(x) {
//     let arrs = []
//     for(let i=0;i<100000;i++){
//         if(i*i<x || i*i ===x){
//             arrs[arrs.length] = i
//         }else{
//             return arrs[arrs.length-1]
//         }

//     }

// };
// 1556. 千位分隔数
// 给你一个整数 n，请你每隔三位添加点（即 "." 符号）作为千位分隔符，并将结果以字符串格式返回。
// 示例 1：
// 输入：n = 987
// 输出："987"
// /**
//  * @param {number} n
//  * @return {string}
//  */
//  var thousandSeparator = function(n) {
//     return n.toLocaleString().replace(/,/g,".")
// };
	</script>

</body>
</html>